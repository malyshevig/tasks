<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Task Manager</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.3/font/bootstrap-icons.css">
    <style>
        body {
            background-color: #f8f9fa;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .app-container {
            max-width: 1700px;
            margin: 0 auto;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .table-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .status-badge {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 500;
        }
        .priority-badge {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .priority-badge:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }
        .priority-input {
            font-size: 0.85rem;
            padding: 4px 8px;
            border-radius: 15px;
            border: 1px solid #dee2e6;
            background-color: white;
            width: 70px;
            text-align: center;
        }
        .priority-1 {
            background-color: #d4edda;
            color: #155724;
        }
        .priority-2 {
            background-color: #d4edda;
            color: #155724;
        }
        .priority-3 {
            background-color: #fff3cd;
            color: #856404;
        }
        .priority-4 {
            background-color: #fff3cd;
            color: #856404;
        }
        .priority-5 {
            background-color: #f8d7da;
            color: #721c24;
        }
        .status-paused {
            background-color: #fff3cd;
            color: #856404;
        }
        .status-failed {
            background-color: #f8d7da;
            color: #721c24;
        }
        .status-running {
            background-color: #d4edda;
            color: #155724;
        }
        .status-completed {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        .status-open {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        .status-in_progress {
            background-color: #cce7ff;
            color: #004085;
        }
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 300px;
        }
        .error-message {
            color: #dc3545;
            text-align: center;
            padding: 20px;
        }
        .filter-input {
            width: 100%;
            padding: 5px 10px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .table th {
            cursor: pointer;
            position: relative;
            user-select: none;
        }
        .table th:hover {
            background-color: #f1f1f1;
        }
        .sort-icon {
            margin-left: 5px;
            font-size: 0.8rem;
            opacity: 0.6;
        }
        .refresh-info {
            font-size: 0.9rem;
            color: #6c757d;
            margin-right: 15px;
        }
        .auto-refresh-toggle {
            margin-right: 15px;
        }
        .action-btn {
            font-size: 0.8rem;
            padding: 4px 8px;
            min-width: 70px;
        }
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1050;
        }
        .editing-priority {
            position: relative;
        }
        .priority-spinner {
            position: absolute;
            right: -25px;
            top: 50%;
            transform: translateY(-50%);
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <div id="toast-container" class="toast-container"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // Компонент для уведомлений
        const Toast = ({ message, type = 'info', onClose }) => {
            useEffect(() => {
                const timer = setTimeout(() => {
                    onClose();
                }, 3000);
                return () => clearTimeout(timer);
            }, [onClose]);

            return (
                <div className={`toast show align-items-center text-bg-${type} border-0`} role="alert">
                    <div className="d-flex">
                        <div className="toast-body">
                            {message}
                        </div>
                        <button type="button" className="btn-close btn-close-white me-2 m-auto" onClick={onClose}></button>
                    </div>
                </div>
            );
        };

        // Основной компонент приложения
        const TaskManager = () => {
            const [tasks, setTasks] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [sortConfig, setSortConfig] = useState({ key: null, direction: 'asc' });
            const [filters, setFilters] = useState({
                id: '',
                name: '',
                status: '',
                lines: '',
                fail_count: '',
                worker_id: '',
                ts: '',
                priority: ''
            });
            const [autoRefresh, setAutoRefresh] = useState(true);
            const [actionLoading, setActionLoading] = useState({});
            const [priorityLoading, setPriorityLoading] = useState({});
            const [editingPriority, setEditingPriority] = useState(null);
            const [toasts, setToasts] = useState([]);

            // Функция для добавления уведомления
            const addToast = (message, type = 'info') => {
                const id = Date.now();
                setToasts(prev => [...prev, { id, message, type }]);
            };

            // Функция для удаления уведомления
            const removeToast = (id) => {
                setToasts(prev => prev.filter(toast => toast.id !== id));
            };

            // Функция загрузки задач
            const loadTasks = useCallback(async () => {
                try {
                    setLoading(true);
                    setError(null);
                    
                    const response = await fetch('http://localhost:8080/api/tasks');
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    setTasks(data);
                } catch (err) {
                    setError('Ошибка загрузки данных. Пожалуйста, проверьте подключение к серверу.');
                    console.error('Ошибка при загрузке данных:', err);
                } finally {
                    setLoading(false);
                }
            }, []);

            // Функция для выполнения действий (Pause/Resume)
            const handleAction = useCallback(async (task, action) => {
                setActionLoading(prev => ({ ...prev, [task.id]: true }));
                
                try {
                    const url = `http://localhost:8080/api/task/${task.id}/${action}`;
                    
                    const response = await fetch(url, { 
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    
                    const updatedTask = await response.json();
                    
                    // Обновляем задачу в состоянии
                    setTasks(prevTasks => 
                        prevTasks.map(t => 
                            t.id === task.id ? updatedTask : t
                        )
                    );
                    
                    // Показываем уведомление об успехе
                    addToast(`Задача ${task.name} ${action === 'pause' ? 'приостановлена' : 'возобновлена'}`, 'success');
                    
                } catch (err) {
                    console.error(`Ошибка при выполнении действия ${action} для задачи ${task.id}:`, err);
                    addToast(`Ошибка при выполнении действия: ${err.message}`, 'danger');
                } finally {
                    setActionLoading(prev => ({ ...prev, [task.id]: false }));
                }
            }, []);

            // Функция для изменения приоритета
            const handlePriorityChange = useCallback(async (taskId, newPriority) => {
                // Валидация: проверяем, что значение является положительным целым числом
                const priorityValue = parseInt(newPriority);
                if (isNaN(priorityValue) || priorityValue < 1) {
                    addToast('Приоритет должен быть положительным целым числом', 'warning');
                    return;
                }

                setPriorityLoading(prev => ({ ...prev, [taskId]: true }));
                setEditingPriority(null);
                
                try {
                    const url = `http://localhost:8080/api/task/${taskId}/priority/${priorityValue}`;
                    
                    const response = await fetch(url, { 
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    
                    const updatedTask = await response.json();
                    
                    // Обновляем задачу в состоянии
                    setTasks(prevTasks => 
                        prevTasks.map(t => 
                            t.id === taskId ? updatedTask : t
                        )
                    );
                    
                    // Показываем уведомление об успехе
                    addToast(`Приоритет задачи обновлен на ${priorityValue}`, 'success');
                    
                } catch (err) {
                    console.error(`Ошибка при изменении приоритета для задачи ${taskId}:`, err);
                    addToast(`Ошибка при изменении приоритета: ${err.message}`, 'danger');
                } finally {
                    setPriorityLoading(prev => ({ ...prev, [taskId]: false }));
                }
            }, []);

            // Загрузка данных при монтировании компонента
            useEffect(() => {
                loadTasks();
            }, [loadTasks]);

            // Настройка автоматического обновления
            useEffect(() => {
                let intervalId;
                if (autoRefresh) {
                    intervalId = setInterval(loadTasks, 9000);
                }
                return () => clearInterval(intervalId);
            }, [autoRefresh, loadTasks]);

            // Функция для обработки сортировки
            const handleSort = (key) => {
                let direction = 'asc';
                if (sortConfig.key === key && sortConfig.direction === 'asc') {
                    direction = 'desc';
                }
                setSortConfig({ key, direction });
            };

            // Функция для обработки изменений в фильтрах
            const handleFilterChange = (key, value) => {
                setFilters(prev => ({
                    ...prev,
                    [key]: value
                }));
            };

            // Функция для применения фильтров и сортировки
            const processData = () => {
                let processedTasks = [...tasks];
                
                // Применяем фильтры
                Object.entries(filters).forEach(([key, value]) => {
                    if (value) {
                        processedTasks = processedTasks.filter(task => 
                            String(task[key]).toLowerCase().includes(value.toLowerCase())
                        );
                    }
                });
                
                // Применяем сортировку
                if (sortConfig.key) {
                    processedTasks.sort((a, b) => {
                        if (a[sortConfig.key] < b[sortConfig.key]) {
                            return sortConfig.direction === 'asc' ? -1 : 1;
                        }
                        if (a[sortConfig.key] > b[sortConfig.key]) {
                            return sortConfig.direction === 'asc' ? 1 : -1;
                        }
                        return 0;
                    });
                }
                
                return processedTasks;
            };

            const processedTasks = processData();

            // Функция для отображения значка сортировки
            const renderSortIcon = (key) => {
                if (sortConfig.key !== key) return null;
                return sortConfig.direction === 'asc' 
                    ? <i className="bi bi-arrow-up-short"></i> 
                    : <i className="bi bi-arrow-down-short"></i>;
            };

            // Функция для форматирования даты
            const formatDate = (dateString) => {
                const date = new Date(dateString);
                return `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
            };

            // Функция для получения класса статуса
            const getStatusClass = (status) => {
                switch(status) {
                    case 'paused': return 'status-paused';
                    case 'failed': return 'status-failed';
                    case 'running': return 'status-running';
                    case 'completed': return 'status-completed';
                    case 'open': return 'status-open';
                    case 'in_progress': return 'status-in_progress';
                    default: return '';
                }
            };

            // Функция для получения класса приоритета
            const getPriorityClass = (priority) => {
                if (priority >= 5) return 'priority-5';
                if (priority >= 4) return 'priority-4';
                if (priority >= 3) return 'priority-3';
                return `priority-${priority}`;
            };

            // Функция для отображения кнопки действия в зависимости от статуса
            const renderActionButton = (task) => {
                if (task.status === 'in_progress' || task.status === 'open') {
                    return (
                        <button
                            className="btn btn-warning btn-sm action-btn"
                            onClick={() => handleAction(task, 'pause')}
                            disabled={actionLoading[task.id]}
                            title="Приостановить задачу"
                        >
                            {actionLoading[task.id] ? (
                                <span className="spinner-border spinner-border-sm" role="status"></span>
                            ) : (
                                'Pause'
                            )}
                        </button>
                    );
                } else if (task.status === 'paused' || task.status === 'failed') {
                    return (
                        <button
                            className="btn btn-success btn-sm action-btn"
                            onClick={() => handleAction(task, 'resume')}
                            disabled={actionLoading[task.id]}
                            title="Возобновить задачу"
                        >
                            {actionLoading[task.id] ? (
                                <span className="spinner-border spinner-border-sm" role="status"></span>
                            ) : (
                                'Resume'
                            )}
                        </button>
                    );
                }
                return null;
            };

            // Функция для отображения элемента приоритета (редактируемого)
            const renderPriorityElement = (task) => {
                if (editingPriority === task.id) {
                    return (
                        <div className="editing-priority">
                            <input
                                type="number"
                                min="1"
                                step="1"
                                className={`priority-input ${getPriorityClass(task.priority)}`}
                                value={task.priority}
                                onChange={(e) => {
                                    // Обновляем значение в реальном времени
                                    const newValue = parseInt(e.target.value);
                                    if (!isNaN(newValue) && newValue >= 1) {
                                        setTasks(prevTasks => 
                                            prevTasks.map(t => 
                                                t.id === task.id ? {...t, priority: newValue} : t
                                            )
                                        );
                                    }
                                }}
                                onBlur={(e) => {
                                    const newValue = parseInt(e.target.value);
                                    if (!isNaN(newValue) && newValue >= 1) {
                                        handlePriorityChange(task.id, newValue);
                                    } else {
                                        // Восстанавливаем предыдущее значение
                                        setEditingPriority(null);
                                        loadTasks(); // Перезагружаем данные для восстановления корректного значения
                                    }
                                }}
                                onKeyDown={(e) => {
                                    if (e.key === 'Enter') {
                                        const newValue = parseInt(e.target.value);
                                        if (!isNaN(newValue) && newValue >= 1) {
                                            handlePriorityChange(task.id, newValue);
                                        } else {
                                            setEditingPriority(null);
                                            loadTasks();
                                        }
                                    } else if (e.key === 'Escape') {
                                        setEditingPriority(null);
                                        loadTasks();
                                    }
                                }}
                                autoFocus
                            />
                        </div>
                    );
                } else {
                    return (
                        <div className="editing-priority">
                            <span 
                                className={`priority-badge ${getPriorityClass(task.priority)}`}
                                onClick={() => setEditingPriority(task.id)}
                                title="Нажмите для изменения приоритета"
                            >
                                {task.priority}
                            </span>
                            {priorityLoading[task.id] && (
                                <span className="priority-spinner">
                                    <span className="spinner-border spinner-border-sm" role="status"></span>
                                </span>
                            )}
                        </div>
                    );
                }
            };

            return (
                <div className="app-container">
                    <div className="header">
                        <h1 className="m-0">Task Manager</h1>
                        <div className="d-flex align-items-center">
                            <span className="refresh-info">
                                Автообновление: {autoRefresh ? 'вкл' : 'выкл'}
                            </span>
                            <div className="form-check form-switch auto-refresh-toggle">
                                <input
                                    className="form-check-input"
                                    type="checkbox"
                                    checked={autoRefresh}
                                    onChange={() => setAutoRefresh(!autoRefresh)}
                                    id="autoRefreshToggle"
                                />
                                <label className="form-check-label" htmlFor="autoRefreshToggle">
                                    Автообновление
                                </label>
                            </div>
                            <button 
                                className="btn btn-primary"
                                onClick={loadTasks}
                                disabled={loading}
                            >
                                <i className="bi bi-arrow-clockwise"></i> 
                                {loading ? ' Загрузка...' : ' Обновить'}
                            </button>
                        </div>
                    </div>
                    
                    <div className="table-container">
                        {error ? (
                            <div className="error-message">
                                {error}
                                <button 
                                    className="btn btn-sm btn-outline-secondary ms-2"
                                    onClick={() => setError(null)}
                                >
                                    Скрыть
                                </button>
                            </div>
                        ) : loading ? (
                            <div className="loading">
                                <div className="spinner-border text-primary" role="status">
                                    <span className="visually-hidden">Загрузка...</span>
                                </div>
                            </div>
                        ) : (
                            <div className="table-responsive">
                                <table className="table table-hover table-striped mb-0">
                                    <thead className="table-light">
                                        <tr>
                                            <th onClick={() => handleSort('id')}>
                                                ID {renderSortIcon('id')}
                                            </th>
                                            <th onClick={() => handleSort('name')}>
                                                Имя файла {renderSortIcon('name')}
                                            </th>
                                            <th onClick={() => handleSort('status')}>
                                                Статус {renderSortIcon('status')}
                                            </th>
                                            <th onClick={() => handleSort('priority')}>
                                                Приоритет {renderSortIcon('priority')}
                                            </th>
                                            <th onClick={() => handleSort('lines')}>
                                                Строки {renderSortIcon('lines')}
                                            </th>
                                            <th onClick={() => handleSort('fail_count')}>
                                                Ошибки {renderSortIcon('fail_count')}
                                            </th>
                                            <th onClick={() => handleSort('worker_id')}>
                                                Worker ID {renderSortIcon('worker_id')}
                                            </th>
                                            <th onClick={() => handleSort('ts')}>
                                                Время {renderSortIcon('ts')}
                                            </th>
                                            <th>Действия</th>
                                        </tr>
                                        <tr>
                                            <th>
                                                <input
                                                    type="text"
                                                    className="filter-input"
                                                    placeholder="Фильтр ID"
                                                    value={filters.id}
                                                    onChange={(e) => handleFilterChange('id', e.target.value)}
                                                />
                                            </th>
                                            <th>
                                                <input
                                                    type="text"
                                                    className="filter-input"
                                                    placeholder="Фильтр имени"
                                                    value={filters.name}
                                                    onChange={(e) => handleFilterChange('name', e.target.value)}
                                                />
                                            </th>
                                            <th>
                                                <input
                                                    type="text"
                                                    className="filter-input"
                                                    placeholder="Фильтр статуса"
                                                    value={filters.status}
                                                    onChange={(e) => handleFilterChange('status', e.target.value)}
                                                />
                                            </th>
                                            <th>
                                                <input
                                                    type="text"
                                                    className="filter-input"
                                                    placeholder="Фильтр приоритета"
                                                    value={filters.priority}
                                                    onChange={(e) => handleFilterChange('priority', e.target.value)}
                                                />
                                            </th>
                                            <th>
                                                <input
                                                    type="text"
                                                    className="filter-input"
                                                    placeholder="Фильтр строк"
                                                    value={filters.lines}
                                                    onChange={(e) => handleFilterChange('lines', e.target.value)}
                                                />
                                            </th>
                                            <th>
                                                <input
                                                    type="text"
                                                    className="filter-input"
                                                    placeholder="Фильтр ошибок"
                                                    value={filters.fail_count}
                                                    onChange={(e) => handleFilterChange('fail_count', e.target.value)}
                                                />
                                            </th>
                                            <th>
                                                <input
                                                    type="text"
                                                    className="filter-input"
                                                    placeholder="Фильтр Worker ID"
                                                    value={filters.worker_id}
                                                    onChange={(e) => handleFilterChange('worker_id', e.target.value)}
                                                />
                                            </th>
                                            <th>
                                                <input
                                                    type="text"
                                                    className="filter-input"
                                                    placeholder="Фильтр времени"
                                                    value={filters.ts}
                                                    onChange={(e) => handleFilterChange('ts', e.target.value)}
                                                />
                                            </th>
                                            <th></th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {processedTasks.length === 0 ? (
                                            <tr>
                                                <td colSpan="9" className="text-center py-4">
                                                    Нет данных, соответствующих фильтрам
                                                </td>
                                            </tr>
                                        ) : (
                                            processedTasks.map(task => (
                                                <tr key={task.id}>
                                                    <td>{task.id}</td>
                                                    <td>{task.name}</td>
                                                    <td>
                                                        <span className={`status-badge ${getStatusClass(task.status)}`}>
                                                            {task.status}
                                                        </span>
                                                    </td>
                                                    <td>
                                                        {renderPriorityElement(task)}
                                                    </td>
                                                    <td>{task.lines}</td>
                                                    <td>{task.fail_count}</td>
                                                    <td>{task.worker_id}</td>
                                                    <td>{formatDate(task.ts)}</td>
                                                    <td>
                                                        {renderActionButton(task)}
                                                    </td>
                                                </tr>
                                            ))
                                        )}
                                    </tbody>
                                </table>
                            </div>
                        )}
                    </div>

                    {/* Контейнер для уведомлений */}
                    {ReactDOM.createPortal(
                        toasts.map(toast => (
                            <Toast 
                                key={toast.id} 
                                message={toast.message} 
                                type={toast.type} 
                                onClose={() => removeToast(toast.id)} 
                            />
                        )),
                        document.getElementById('toast-container')
                    )}
                </div>
            );
        };

        // Рендерим приложение
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TaskManager />);
    </script>
</body>
</html>